# 1、🚀 开发辅助


# 2、🐾 Git & VCS

## 解决 `fatal: 无法访问 'https://github.com/gukt/rainbow.git/'：LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443` 的问题。

**解决方案：**

查看是否设置了全局代理：

```bash
$ git config --global http.proxy
```

如果没看到输出，说明没有设置。运行如下命令进行设置：

```bash
git config --global http.proxy 127.0.0.1:1087
```

注意：以上 `127.0.0.1:1087` 就是我们的代理地址，这是选择的是 HTTP 代理。

再次运行 `git config --global http.proxy` 命令，可以看到地址就说明成功了。

```bash
$ git config --global http.proxy
127.0.0.1:1087
```

现在直接在命令行窗口执行 `git push` 就可以看到一切正常了。

如果需要移除代理，运行如下命令：

```bash
$ git config --global --unset http.proxy
```


## 如何和远程仓库建立关联

如果项目已存在于远程仓库但没有本地仓库，需要克隆到本地：

```bash
git clone <http://git.laogu.io:10001/root/url-rescuer.git>
cd hello
touch README.md
git add README.md
git commit -m "add README"
git push -u origin master
```

**如果项目已存在于本地且还没有和任何仓库关联**，则按如下步骤将本地项目push到远程仓库：

```bash
#进入已存在的那个目录
cd path_to_repo
#Initialize an empty Git repository
git init
#添加一个remote名称（origin)和远程仓库关联
git remote add origin <http://git.laogu.io:10001/root/url-rescuer.git>
git add .
git commit -m "Initial commit"
#将变化推送到远程仓库中的master分支
git push -u origin main
#此时会提示用户名和密码，输入后回车。
```

如果本地已经是一个 git 仓库，需要和远程仓库关联：

```bash
cd existing_repo
git remote rename origin old-origin
git remote add origin <http://git.laogu.io:10001/root/nn-stats.git>
git push -u origin --all
git push -u origin --tags
```

 

## 如何删除已经添加到远程仓库中的需要忽略的文件或文件夹

```bash
#要删除的是远程仓库中已经提交过的文件或目录，但是working tree中的文件需要保留的
#因此我们只需要将index区域中的文件删掉后提交，然后将修改push到远程仓库即可
#-r表示递归删除，--cached表示仅删除index区的文件
git rm -r --cached .idea build
#提交更改
git commit -m "Remove .idea and build folder"
#将更改push到远程仓库
git push -u origin master
#至此，刷新远程仓库看看相关文件是否已经被删除
```

 



# 3、💿 MySQL / JPA / ORM

## 解决 glibc 版本过低导致安装 mysql 5.7 失败的问题

### 问题描述

```sh
错误：Package: mysql-community-client-5.7.23-1.el7.x86_64 (mysql57-community)
          Requires: libc.so.6(GLIBC_2.14)(64bit)
```

### 解决方案

这是因为原系统中的glibc版本是2.12，需要升级到 2.17。

```sh
ldd --version
ldd (GNU libc) 2.12
```

升级 glibc：

```sh
#首先先要安装gcc
yum install -y gcc

#下载glibc2.17源文件并解压到指定的目录
xz -d glibc-2.17.tar.xz 
tar -xvf glibc-2.17.tar 
cd glibc-2.17 
mkdir build 
cd build 

#编译
../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin

#安装
make && make install
...
Your new glibc installation seems to be ok.
make[1]: Leaving directory `/root/glibc-2.17'

#查看是否安装成功
ldd --version
ldd (GNU libc) 2.17
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
由 Roland McGrath 和 Ulrich Drepper 编写。

Cheers!!!
```



## 解决 WARN: Establishing SSL connection without server's identity verification is not recommended... 的问题

在连接字符串中添加 `useSSL=false` 属性：

```
jdbcUrl=jdbc:mysql://db.domain.com:3306/test?useSSL=false&useUnicode=true&zeroDateTimeBehavior=convertToNull&characterEncoding=utf-8
```



## MySQL 中的整形（Integer）和小数？

MySQL 中有以下几种整形，表示的范围不一样：

* TINYINT：1 个字节。(-128，127)，无符号：(0，255)
* SMALLINT：2 个字节（(-32 768，32 767)），无符号：(0，65 535)
* MEDIUMINT：3 个字节：(-8 388 608，8 388 607)，无符号：(0，16 777 215)
* INT 或 INTEGER：4 个字节：(-2 147 483 648，2 147 483 647)，无符号：(0，4 294 967 295)
* BIGINT：8 个字节：(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)，无符号：(0，18 446 744 073 709 551 615)

小数：

* FLOAT：4 bytes，单精度浮点值：(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)，无符号：0，(1.175 494 351 E-38，3.402 823 466 E+38)
* DOUBLE：8 个字节：双精度浮点值：(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)，无符号：0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)
* DECIMAL：通常用于存储货币这种保留精度的小数值。
  * 语法：column_name ``DECIMAL``(P,D);
  * `P`是表示有效数字数的精度。 `P`范围为`1〜65`。
  * D是表示小数点后的位数。 D的范围是0~30。MySQL要求D小于或等于(<=)P
  * `DECIMAL(P，D)`表示列可以存储`D`位小数的`P`位数。十进制列的实际范围取决于精度和刻度。

添加 columnDefinition



## 字段限定：设置最大长度及默认值

### 设定字符串列的最大长度及默认值

```java
@Column(nullable = false, columnDefinition = "varchar(25) default ''")
private String platform;

@Column(nullable = false, length = 100)
@JsonIgnore
private String password;
```

### 设定各种类型整形字段长度及默认值

```java
@Column(nullable = false, columnDefinition = "int(11) default 0")
private Long fromId = 0L;
```

**注意：int(11) 表示字符的显示宽度，不是最大长度为 11。**

int 表示 4 个字节表示的整形，其表示范围如下：

* 有符号：(-2 147 483 648，2 147 483 647)
* 无符号：(0，4 294 967 295)

#### 设定 boolean 类型默认值：

```java
@Column(nullable = false, columnDefinition = "bit default 0")
private Boolean inactive = false;

@Column(nullable = false, columnDefinition = "mediumint default 0")
private Integer sid;

@Column(nullable = false, columnDefinition = "tinyint default 0")
private Integer type;
```

MySQL 支持的整形类型有：TINYINT（1 个字节），SMALLINT（2 个字节），MEDIUINT（3 个字节），INT/INTEGER（4 个字节），BIGINT（8 个字节），对于 JAVA 中的 Long 型，MYSQL 中要用 BIGINT 存储。

#### 设置 JSON 字段类型及默认值：

```java
@TypeDefs({
        @TypeDef(name = "json", typeClass = JsonStringType.class),
})
public class Mail {
  	...
		@Type(type = "json")
    @Column(nullable = false, columnDefinition = "json default '{}'")
    private Map<String,Object> attachment;
    ...
}
```



## 不能使用 `from` 做为 MYSQL 字段名。

很显然了，FROM 是最常用的关键字。



## 添加对 JSR-303（验证） 的支持

添加依赖：

```groovy
implementation 'javax.validation:validation-api:2.0.1.Final'
implementation 'org.hibernate:hibernate-validator:7.0.1.Final'
```

`hibernate-validator`是 JSR-303 API 的一个实现，如果不添加，启动时会提示如下错误：

```
...
Add an implementation, such as Hibernate Validator, to the classpath
```

## Yum 安装 MySQL 5.6

```bash
$ yum remove mysql57-community-release.noarch
$ yum clean all
$ yum install <https://dev.mysql.com/get/mysql57-community-release-el6-11.noarch.rpm>
$ yum -y install mysql-community-server
```





# 4、☘️ Spring & SpringBoot

## IDEA 提示：Spring Boot Configuration Annotation Processor not configured.

这是因为当前项目中缺少 `spring-boot-configuration-processor` 依赖，添加如下行：

build.gradle：

```groovy
dependencies {
  	...
    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
}
```

添加后，重新 `Load gradle changes` 即可。



## 按类型注入时，发现有多个对象可以注入怎么办？

**问题描述：**

```java
org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'io.laogu.pylon.tmp.FooService' available: expected single matching bean but found 2: fooServiceA,fooServiceB
```

这是因为通过 `@Autowired` 注入时，发现了指定的类型有两个实例，Spring 不知道用哪个，有两个方案可以解决：

1. 使用 `@Qualified("fooServiceA")` 指定名称，按名称注入。
2. 在 `FooServiceA` 或 `FooServiceB` 上的某一个上使用 `@Primary`。



## 关于 properties 和 yaml 文件中的数组配置 

application.properties:

```properties
my.servers[0]=dev.example.com
my.servers[1]=another.example.com
```

application.yaml:

```yaml
my:
servers:
	- dev.example.com
	- another.example.com
```

自动从 application.properties/yaml 中读取配置到结构化对象：

```java
@ConfigurationProperties(prefix="my")
public class Config {

	private List<String> servers = new ArrayList<String>();

	public List<String> getServers() {
		return this.servers;
	}
}
```



## Spring 中判断是否是资源类型

```
Class<?> clazz = getReturnValueType(value, returnType);
return clazz != InputStreamResource.class && Resource.class.isAssignableFrom(clazz);
```



## Spring data jpa 映射 snake-case 字段名

在使用 `Spring data jpa` 时，默认情况下，Spring 会将 `camel-case` 形式的对象属性名，映射到数据中的的字段名为 `snake-case` 形式。

比如：`firstName` 属性会被映射成 `first_name` 字段。

如果我们期望数据库字段名保持和属性一直，则可以添加如下设置：

```basic
jpa.hibernate.naming.physical-strategy = org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```



## 解决 Spring boot: could not initialize proxy - no Session 的问题

### 问题描述

```properties
2018-09-08 13:58:04.533  WARN 96697 --- [nio-8082-exec-3] .m.m.a.ExceptionHandlerExceptionResolver : Resolved exception caused by Handler execution: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: failed to lazily initialize a collection of role: com.yfs.cms.admin.domain.Post.meta, could not initialize proxy - no Session; nested exception is com.fasterxml.jackson.databind.JsonMappingException: failed to lazily initialize a collection of role: com.yfs.cms.admin.domain.Post.meta, could not initialize proxy - no Session (through reference chain: com.yfs.cms.admin.util.ApiResponse["data"]->org.springframework.data.domain.PageImpl["content"]->java.util.Collections$UnmodifiableRandomAccessList[0]->com.yfs.cms.admin.domain.Post["meta"])
```

### 解决方案

在 `application.properties` 文件中，添加这一行（**或不添加，默认是开启的**）

```properties
spring.jpa.open-in-view=true
```

## 如何启用 devtools

1. 打开 `build.gradle` 文件，在 `dependencies` 中添加依赖项：`compile("org.springframework.boot:spring-boot-devtools")`

2. 打开 `application.properties` ，设置两个开关

   ```java
   spring.devtools.livereload.enabled=true
   spring.devtools.restart.enabled=true
   ```

3. 如果需要支持 `liverload` ，需下载并安装 `livereload` 插件，这样当app重启后，浏览器页面也会自动reload。

4. 打开 IDEA 的 `Preferences` -> `Build, Execution, Deployment` -> `Compiler` -> 将 `Build project automatically` 勾选上。

5. 在 IDEA 中输入快捷键 `shift+option+command+/` ，选择 `Registry...` ，勾选 `compiler.automake.allow.when.app.running`

## 启动时，提示：Cannot find template location: classpath:/templates/ (please add some templates or check your Thymeleaf configuration)

这是因为检测到没有 `templates` 目录、或该目录没有任何 `template` 文件，可以忽略。

解决方案：在 `application.properties` 中添加如下配置：

```java
spring.thymeleaf.check-template=false
spring.thymeleaf.check-template-location=false
```

## 启动时，提示：For Jackson Kotlin classes support please add “com.fasterxml.jackson.module:jackson-module-kotlin” to the classpath

解决方案：在 `build.gradle` 的 `dependencies` 里添加依赖即可：

```groovy
dependencies {
    compile group: 'com.fasterxml.jackson.module', name: 'jackson-module-kotlin', version: '2.11.2'
}
```

## org.hibernate.LazyInitializationException: could not initialize proxy [com.jjx.domain.Role#1] - no Session

解决方案：在 `application.properties` 里添加如下行：

```java
open-in-view: true
```

这是最简单的解决方案，更多关于`open-in-view` 的缺点和反模式，请更深入地学习。

## HikariPool-1 - idleTimeout is close to or more than maxLifetime, disabling it.

这是因为 `idleTimeout`（默认为 10 分钟） 不能设置为大于 `maxLifetime`（默认 30 分钟） - 1秒，如果是，则会永远不空闲。

解决方案：如果你重新设置了 `maxLifeTime` 且小于或等于 10 分钟，则也要相应的重设 `idleTimeout`。

```java
datasource.hikari.max-lifetime=480000
datasource.hikari.idle-timeout=360000
```

# 5、🔥 VUE

## Element 中选择器每次选择后不记录选择项的最佳实践

在有些场景下，比如批量操作下拉框，不管选择项目发生如何改变，希望默认选中项总是定位在：`批量操作...`

这时，不应该设定 v-model 为一个变量，只用设置 value = "" 即可。

```vue
<el-select value="" v-loading.fullscreen.lock="fullscreenLoading"
                 placeholder="批量操作..." @change="onBatchActionChanged">
```

如果设定了 `v-model` 给一个变量，意味着每次发生选择项目变更，被绑定变量就自动设置为了最新选择的值，那么，每次在发生 @change 事件后，还需要在代码里将其设为 null ，多次一举。

NOTE：@change 只需要指定方法名就可以，选中项会作为第一个参数传入 onBatchActionChanged 处理函数中。

> 对于那些选择后，需要等待进一步确认的下拉框，需要使用 v-model 绑定属性。



## 一个典型的 radio group 的写法

```vue
<el-radio-group v-model="formData.kind">
  <el-radio :label="1">支持</el-radio>
  <el-radio :label="2">反对</el-radio>
</el-radio-group>
```

> 注意事项
>
> 1. 写代码时间长了可能有惯性思维，觉得 value 应该是值，label 应该是显示的名称，但是在 element ui 中并不是这样，label 用来表示值，显示的文本写在标签中间。
> 2. 如果 label 之前不加冒号，则认为值是 String 类型，如果想绑定 Number 类型，在 label 前面加个冒号即可。



## 使用 vue-cli 搭建脚手架

### 安装 node 和 npm

```sh
#检查有没有安装过nodejs
$node -v

#安装node@mac
$ brew install nodejs

#如果已经安装过node但不知道在那里
$ brew info nodejs

#查看版本
$ node -v
v10.4.1

#查看npm版本
$ npm -v
6.2.0

#查看全局node_modules所在路径
$ find / -name node_modules
#一般会安装在/usr/local/lib/node_modules目录

#安装淘宝镜像
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

### 安装webpack

```sh
npm install webpack -g
```

### 安装vue-cli

```sh
npm install vue-cli -g
```

### 初始化项目脚手架

```sh
#进入项目所在根目录
cd ~/github

#初始化项目脚手架(一路回车下去)
vue init webpack vue-demo1
```

 

## TypeError: Cannot read property 'length' of undefined

问题描述与解决方案：

出现这种问题，一般去检查哪里的 for 循环使用了数组，但这个数组未定义；或者你主观认为已经初始化过了，但在代码的某个地方可能误将它又覆盖掉了。

比如：

```vue
<el-checkbox-group v-model="formData.tags" :max="4">
   <el-checkbox v-for="item in tags" :key="item" :label="item">{{ item }}</el-checkbox>
</el-checkbox-group>

<script>
defaultFormData = {
 	k1: v1
}

data() {
  return {
    formData: {
      // 你认为这不明明是定义过了吗？
      tags: []
    }
  }
},
created() {
  // 但是这里由于疏忽，将 formData 用 defaultFormData 中的数据给覆盖了。
  // 这段代码的本意是要合并两个对象属性
  this.formData = Object.assign({}, defaultFormData)
}
</script>
```



# 6、♨️ JAVA

## 解决 VisualVM 插件中心连接不上的问题

因为 Java VisualVM 默认的插件中心已关闭服务。新的地址是：https://visualvm.github.io/pluginscenters.html。

打开连接，找到对应的版本，在浏览器中打开地址。比如以下这个地址：

```
JDK 8 Update 40 - 121
JDK 7 Update 79 - 80
https://visualvm.github.io/archive/uc/8u40/updates.xml.gz
```

步骤：

1. 打开 https://visualvm.github.io/archive/uc/8u40/updates.xml.gz 。
2. 在打开页面第一行，找到 Catalog URL 后面的地址，并拷贝。
3. 打开 VisualVM > 工具 > 插件 > 设置 > 编辑。
4. 将地址拷贝进去并保存。



## Java VisualVM 和 JConsole

Java VisualVM 和 JConsole 都是基于 JMX 的 JVM 管理和统计工具。VisualVM 也提供 JConsole 的插件，但没必要用这个插件。因为 VisualVM  本身就是 JConsole 的替代版本。JConsole 有的功能 VisualVM 都有。



## 如何启用 JVM 飞行记录器并记录

JDK 8u40 发布前，JVM 须开启标志位：

```bash
-XX:+UnlockCommercialFeatures
-XX:FlightRecorder
```

JDK 8u40 以后，能在运行时启用 Java Flight Recorder。更多说明请见这篇 [官方文档的翻译](https://cs.xieyonghui.com/java/java-flight-recorder_72.html)。

下面是关于如何在运行时开启 Java Flight Recorder 的说明：

输入 jcmd 查看当前所有进程：

```bash
$ jcmd
```

解锁 commercial_features：

```bash
$ jcmd <pid> VM.unlock_commercial_features
```

启动一个飞行记录：

```bash
$ jcmd <pid> JFR.start
```

更多关于启动飞行记录的详细控制，请参考 JFR.start 命令的帮助：

```bash
$ jcmd <pid> help JFR.start
```

参考：

1. [Java Flight Recorder飞行记录器用法图解 (官方文档译)](https://cs.xieyonghui.com/java/java-flight-recorder_72.html)
2. https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/run.htm#JFRUH176
3. https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH173

## 解决 Java Mission Control (jmc) 在 Max OS X 上不能启动的问题

### 问题描述

打开 jmc 时，可以显示启动界面，但进不了 jmc。

操作系统版本：Mac OS Big Sur 11.4

Java 版本：JDK 1.8.0_181

### 解决方案

这是一个 bug，请见这里的[讨论](https://stackoverflow.com/questions/48400346/java-mission-control-from-jdk-1-8-0-161-frozen-upon-startup-on-mac-os-x)。换了 JDK 版本就可以了。

亲测换了版本 1.8.0_51 可以进入，其他版本没有试过。



## 查看本机安装的所有 Java 虚拟机

```bash
$ /usr/libexec/java_home -V
Matching Java Virtual Machines (7):
    14.0.2 (x86_64) "Oracle Corporation" - "Java SE 14.0.2" /Library/Java/JavaVirtualMachines/jdk-14.0.2.jdk/Contents/Home
    11.0.8 (x86_64) "Oracle Corporation" - "Java SE 11.0.8" /Library/Java/JavaVirtualMachines/jdk-11.0.8.jdk/Contents/Home
    1.8.201.09 (x86_64) "Oracle Corporation" - "Java" /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home
    1.8.0_181 (x86_64) "Oracle Corporation" - "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home
    1.8.0_51 (x86_64) "Oracle Corporation" - "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home
    1.7.0_80 (x86_64) "Oracle Corporation" - "Java SE 7" /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home
    1.7.0_79 (x86_64) "Oracle Corporation" - "Java SE 7" /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home
/Library/Java/JavaVirtualMachines/jdk-14.0.2.jdk/Contents/Home
```

## JVM 监控工具列表

* [Java Mission Control (jmc)](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr002.html#BABIBBDE)

  用于 HotSpot JVM 的新的分析和诊断的平台，它提供了高性能的基本监控、管理、时间分析和诊断工具套件。JMC 最大限度的减少了性能开销。

* [jcmd](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr006.html#BABEHABG)

  用于向 JVM 发送诊断命令请求，这些请求对于控制 Java Flight Recordings 很有用。JFR 用于对带有飞行记录事件的 JVM 和 Java 应用程序进行故障排除和诊断。

* [Java VisualVM](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr010.html#BABEEIFH)

  此实用程序提供了一个可视化界面，用于在 Java 虚拟机上运行时查看有关 Java 应用程序的详细信息。此信息可用于对本地和远程应用程序进行故障排除，以及分析本地应用程序。

  还提供了一些插件供自行选择安装。比如常用的：Thread Inspector、Visual GC、VisualVM-Mbeans 等。

* [JConsole](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr009.html#BABDCICF)

  此实用程序是一种基于 Java 管理扩展 (JMX) 的监视工具。该工具使用 Java 虚拟机中的内置 JMX 检测来提供有关正在运行的应用程序的性能和资源消耗的信息。

* [jmap](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr014.html#BABGAFEG)

  此实用程序可以从 Java 进程、核心文件或远程调试服务器获取内存映射信息，包括堆直方图。

* [jps](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr015.html#BABHCEDC)

  此实用程序列出了目标系统上已检测的 Java HotSpot VM。该实用程序在嵌入 VM 的环境中非常有用，也就是说，它使用 JNI 调用 API 而不是`java`启动器启动。

* [jstack](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr016.html#BABFCHDE)

  此实用程序可以从 Java 进程获取 Java 和本机堆栈信息。在 Oracle Solaris 和 Linux 操作系统上，该实用程序还可以从核心文件或远程调试服务器获取信息。

* [jstat](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr017.html#BABCDBEA)

  此实用程序使用 Java 中的内置检测来提供有关正在运行的应用程序的性能和资源消耗的信息。该工具可用于诊断性能问题，尤其是与堆大小和垃圾收集相关的问题。

* [jstatd 守护进程](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr033.html#CJGHGBFD)

  该工具是一个远程方法调用 (RMI) 服务器应用程序，它监视已检测 Java 虚拟机的创建和终止，并提供一个接口以允许远程监视工具连接到在本地主机上运行的 VM。

* [visualgc](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr018.html#BABCDEBE)

  此实用程序提供垃圾收集系统的图形视图。与 一样`jstat`，它使用 Java HotSpot VM 的内置检测。

* 其他第三方工具。如：[JProfiler](https://www.ej-technologies.com/products/jprofiler/overview.html) （[IDEA 中也提供了相关插件](https://blog.csdn.net/wytocsdn/article/details/79258247)）

参考：

1. [官方文档：Monitoring Tools](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr025.html)
2. [性能诊断利器 JProfiler 快速入门和最佳实践](https://segmentfault.com/a/1190000017795841)
3. [JProfiler性能分析工具详解](https://www.jianshu.com/p/784c60d94989)
4. [Intellij IDEA集成 JProfiler性能分析神器](https://blog.csdn.net/wytocsdn/article/details/79258247)

## 输入 exit/q 回车后退出

```java
Scanner scanner = new Scanner(System.in);
while(scanner.hasNext()) {
  String s = scanner.next().replace("\\n", "").toLowerCase();
  System.out.println(s);
  if("exit/q".contains(s)) {
    System.out.println("Exited.");
    break;
  }
}
```

## 解决 Unknown channel option 'TCP_NODELAY' for channel '[id: 0xa05092f5]' 的问题。

这是因为在使用 netty 的 ServerBootstrap 启动服务器时，设定了 

```
.option(ChannelOption.TCP_NODELAY, true)。
```

解决方案：使用 `childOption(ChannelOption.TCP_NODELAY, true)`：

```java
bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childOption(ChannelOption.TCP_NODELAY, true)
                // .handler(new LoggingHandler(LogLevel.INFO))
                .childHandler(new ChannelInitializer<Channel>() {
                  ...
```



## 通过 -Xbootclasspath 更改 Bootstrap ClassLoader 的加载目录

最准确全面的解释还是看官方文档：

https://docs.oracle.com/cd/E15289_01/JRCLR/optionx.htm#i1021218

 

## 运行 Java 程序时，打印出类加载的详细信息

只要在 `Run/Debug Configurations` 中的 `VM Options` 中添加 `-verbose`，输出如下：

```
...
[Opened /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.lang.Object from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.io.Serializable from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.lang.Comparable from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.lang.CharSequence from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.lang.String from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.lang.reflect.AnnotatedElement from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
...
```



## 如何让自定义的类由 Bootstrap ClassLoader 加载

我们知道，Bootstrap Class Loader 会加载 sun.boot.class.path 虚拟机选型指定目录下的所有类。

下面是一个典型的 sun.boot.class.path  目录内容：

```
/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/sunrsasign.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/classes
```

其中 `/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home` 是本机 `$JAVA_HOME` 指定的目录。

将上述 sun.boot.class.path  输出内容简化一下并逐行打印如下：

```
$JAVA_HOME/jre/lib/resources.jar
$JAVA_HOME/jre/lib/rt.jar
$JAVA_HOME/jre/lib/sunrsasign.jar
$JAVA_HOME/jre/lib/jsse.jar
$JAVA_HOME/jre/lib/jce.jar
$JAVA_HOME/jre/lib/charsets.jar
$JAVA_HOME/jre/lib/jfr.jar
$JAVA_HOME/jre/classes
```

第一个方法：只用将期望让 Bootstrap ClassLoader 加载的自定义类放入 `$JAVA_HOME/jre/classes` 目录中即可。

第二个方法：设置 -Xbootclasspath 这个虚拟机选型（命令帮助，请见[官方文档](https://docs.oracle.com/cd/E15289_01/JRCLR/optionx.htm#i1021218)）比如：

```
-Xbootclasspath:/a <path-to-your-custom-class>
```



## Assertions.assertEquals 和 assertSame 的区别

两者都是用于比较两个对象是否相等；不同点是：

* assertEquals 用的是 equals 比较；

* assertSame  用的是 == 比较。

如果两个对象中，有一个为 null，或两者都为 null；两个方法都是返回 false。

assertEquals:

```java
static boolean objectsAreEqual(Object obj1, Object obj2) {
  if (obj1 == null) {
    return (obj2 == null);
  }
  return obj1.equals(obj2);
}
```

assertSame :

```java
static void assertSame(Object expected, Object actual, String message) {
  if (expected != actual) {
    failNotSame(expected, actual, message);
  }
}
```

**因此：对于没有重写过 equals 方法的两个对象，调用那个都一样。对于重写过 equals  方法的，可能会产生不同的判断结果。**



## 如何在 gradle 中设置 JDK 版本

build.gradle:

```groovy
...
java {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}
...
```

[官方文档](https://docs.gradle.org/6.8.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html#org.gradle.api.tasks.compile.JavaCompile:sourceCompatibility)



## java: 无效的目标发行版: 11

解决方案：

1. 第一种方式：在 `build.gradle` 中指定：

   ```groovy
   ...
   java {
       sourceCompatibility JavaVersion.VERSION_1_8
       targetCompatibility JavaVersion.VERSION_1_8
   }
   ...
   ```

   说明：

   * `sourceCompatibility` 控制的就是 `Project Structure > Project Settings > Project` 中的 `Project languange level` 

   * `targetCompatibility` 控制的是 `Preferences > …  > Java Compiler` 中的 `Project bytecode version`

2. 第二种方式：手动设置

   首先，打开 `Project Structure > Project Settings > Project`，看看 `Project SDK` 和 `Project languange level` 是否匹配。

   其次：打开 IDEA 的 `Preferences`，找到 `Java Compiler`，更改 `Project bytecode version`。




## IPV6 最大字符串长度

**45个字符**，数据库设计时存储IPv6需要 varchar(45)。

其中：`0000:0000:0000:0000:0000` 有 `8 * 4 + 7 = 39` 个字符。

对于 [IPv4-Mapped IPv6 Address](https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2)，加起来就是 45。

```
0000:0000:0000:0000:0000:ffff:192.168.100.228
```

在 Linux上，请参见常量 `INET6_ADDRSTRLEN` （请参阅man inet_ntop）：

```
#define INET6_ADDRSTRLEN 46
```

最后一个字符用于终止 NULL，所以最大长度为 45。



## 为已存在的多模块项目添加一个新的 SpringBoot 子模块 🚀

操作步骤：

1. 在 IDEA 中，点击项目根路径，右键选择 `New > Module...`

2. 在出现的 `New Module` 弹出框中，选择 `Spring Initializr`，然后按向导创建好子模块（后续操作略）。

3. 子模块（假设模块名称叫 `xxx-app`）被添加到 Project 中了，但是它默认作为和原 Project 平级的项目了，我们需要做一些手动操作：

4. 点击 Gradle 侧边栏，找到刚刚创建好的模块名称，删除掉，然后点击上面的 “+” 按钮，将子模块添加进来。

5. 打开项目根目录的 `settings.gradle` 文件，找到 include(…)， 将模块名添加进去：

   ```java
   include('app', 'list', 'utilities', 'xxx-app')
   ```

现在，点击 “`Reload All Gradle Projec`t” 即可（在 IDEA 的 Gradle 侧边栏中）。



## Java 中的 char 占几个字节？

2 个字节（或 16 位）。类型 char 在 Java 中用来表示一个字符。

它**在内存中的编码**是用的 unicode 编码。



## 通过名称获得一把锁

```java
private final ConcurrentHashMap<String, Object> parallelLockMap;
protected Object getClassLoadingLock(String className) {
  Object lock = this;
  if (parallelLockMap != null) {
    Object newLock = new Object();
    lock = parallelLockMap.putIfAbsent(className, newLock);
    if (lock == null) {
      lock = newLock;
    }
  }
  return lock;
}
```

摘抄自：`ClassLoader.getClassLoadingLock`



## 关于 @implSpec 注释

```java
     * @implSpec
     * This method invokes {@link #readNBytes(int)} with a length of
     * {@link Integer#MAX_VALUE}.
		public byte[] readAllBytes() throws IOException {
        return readNBytes(Integer.MAX_VALUE);
    }
```

## 不同摘要算法  CPU 占用率比较

![img](/Users/ktgu/Pictures/typora/131646500458774.jpg) 

结论：

- 数据摘要算法的处理是很快的，在一般配置的PC机上使用MD5算法，处理1G的文件数据只需20-30秒（有些专用设备声称达 3GB/秒），不会对应用或机器带来过多负载。
- MD5、SHA1虽然被发现存在缺陷（碰撞），但在近几年内，仍然可以大量使用。
- SHA256/384/512 的速度较慢，可以用于少量数据摘要，目前不适合用于大文件校验。
- MD5计算速度要明显优于CRC32。

参考：

1. https://blog.csdn.net/xiaofei0859/article/details/52683533

## 关于 ClassLoader “双亲委托” 的翻译问题

观点：

1. 英文不好的人不要翻译计算机书籍。
2. 计算机不好的人不要翻译英文计算机书籍。
3. 英文好的人不要看翻译的计算机书籍。

看 ClassLoader 时，几乎每篇文章都要提到“双亲委托“加载模式。虽然看懂了原理，但缺仍然自己没懂。始终怀疑自己没有看懂，因为对 “双亲委托”  这个名词概念的理解仍然是云里雾里。

实际上，这只是一个翻译问题。[英文原文](https://docs.oracle.com/javase/tutorial/ext/basics/load.html)

**The Java Class Loading Mechanism**

> The Java platform uses a delegation model for loading classes. **The basic idea is that every class loader has a "parent" class loader.** When loading a class, a class loader first "delegates" the search for the class to its parent class loader before attempting to find the class itself.

把 Parents 翻译成“双亲”，我他妈的真的服了，这么多年害苦了多少人？回想最早看到“双亲委派模型”时，顿时感到好高级，好难懂的样子，这样势必会给新学者造成心理上的障碍。读完以后，糟糕的翻译更是给新学者带来心理上的创伤。

双亲实在是太误导人了，父母加在一起叫双亲。但 ClassLoader 类加载机制里，说的是父母吗？首先就没有平级的父 + 母的概念；而且还有爷爷辈的概念呢。

哪怕你翻一个很土的但比较贴切的名字也好，比如：向上、溯源、都可以。或者父级代理什么的。

面向对象里有父类子类，还好没有翻译成“ 双亲”类。因为一般说父类英文里都是 Parent Class ，用的是单数，所以好翻译。麻痹到了 ClassLoader 这里，英文里用了复数，就不知道如何翻译了。英文不好，对 JVM 理解不深不是你的错，但你出书误导后学就是你的错了。

知乎看到有人建议翻译成：父辈代理、上溯委托 都听不错的。哪怕你用“向上委托”都可以，至少不会造成曲解。



# 7、🐳 Docker

## 在基于 debian 的容器中安装 vim

以下以安装 vim 为例：

```sh
# 首先得以交互方式进入容器
$ docker exec -it xxx bash

# 备份旧的下载源，并添加国内网易的下载源
# NOTE: 也可以不用更改，官方默认的下载速度也挺快的
$ mv /etc/apt/sources.list /etc/apt/sources.list.bak
$ echo "deb http://mirrors.163.com/debian/ jessie main non-free contrib" >/etc/apt/sources.list
$ echo "deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib" >>/etc/apt/sources.list
$ echo "deb-src http://mirrors.163.com/debian/ jessie main non-free contrib" >>/etc/apt/sources.list
$ echo "deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib" >>/etc/apt/sources.list

# Retrieve new lists of packages
$ apt-get update 
$ apt-get install -y vim
```



### 安装 portia

```sh
docker run \
	-v /data/portia:/app/data/projects:rw \
	-p 19001:9001 \
	--restart always \
	--name portia \
	scrapinghub/portia
```



## 制作镜像时出现 unable to initialize frontend: Dialog 异常

### 1、问题描述

制作镜像时出现异常：`unable to initialize frontend: Dialog`

```
debconf: unable to initialize frontend: Dialogdebconf: (TERM is not set, so the dialog frontend is not usable.)debconf: falling back to frontend: Readlinedebconf: unable to initialize frontend: Readlinedebconf: (This frontend requires a controlling tty.)debconf: falling back to frontend: Teletype
```

原因是因为使用apt-get安装依赖时，可能会有对话框，制作镜像时如果没有对对话框响应会导致失败。

### 2、解决方案

在出错指令之前加上：

```docker
ENV DEBIAN_FRONTEND noninteractive
```



## 解决 openjdk8-jdk-alpine 镜像默认没有安装字体而导致 Kaptcha 生成验证码失败的问题

### 1、问题描述

当我们选择 `8-jdk-alpine` 作为运行 `java` 项目的镜像时，如果 java 项目中使用到 [Kaptcha](https://mvnrepository.com/artifact/com.github.penggle/kaptcha/2.3.2) 这个库来生成图形验证码，就会出现因为找不到字体而导致的异常。

这是因为 `8-jdk-alpine` 镜像中没默认有安装字体导致的。

### 2、解决方案

在 `Dockerfile` 文件中添加如下命令，安装必要的依赖：

```docker
RUN apk add --no-cache ttf-dejavu fontconfig
```



## 安装 gitlab

```bash
$ docker run \
	-d \
  -p 18081:80 \
  --privileged=true \
  --restart always \
  --volume /data/gitlab/config:/etc/gitlab:Z \
  --volume /data/gitlab/logs:/var/log/gitlab:Z \
  --volume /data/gitlab/data:/var/opt/gitlab:Z \
  --name gitlab \
  beginor/gitlab-ce:latest
```



# 8、🐧 Linux

## 执行 crontab -l  命令提示：no crontab for root

这是因为 liunx 服务器第一次使用 crontab ，还没有生成对应的文件导致的。

解决方案：

输入 crontab -e 命令，按 ESC，按 :wq 回车退出。再执行 crontab -l 就不提示了。



## 查看磁盘占用空间

```bash
du -ah --max-depth=1 ./
```



## linux 服务器上每天 3 点执行命令

输入以下命令，编辑计划任务

```bash
$ crontab -e
```

在打开的编辑器中，输入以下内容：

```bash
# 每天 3 点 重启服务
0 3 * * * echo "Restarting server." >> /tmp/test.txt
0 3 * * * /data/shuliao/bin/server.sh restart
```

 按 :wq 保存退出。



## docker 中构建 vue 前端代码后拷贝到 nginx 目录中

```sh
# jenkins容器默认构建目录存放在：/var/jenkins_home/workspace/中
# nginx容器存放静态文件的目录为：/usr/share/nginx/html
# 因此，jenkins 构建好 vue 的静态文件后，需要在容器内直接拷贝到 nginx 容器某个文件夹下的命如下：
# 进入 jenkins 容器
$ docker exec -it jenkins sh
# 拷贝 dist 目录到 nginx 容器的 /usr/share/nginx/html/url-rescuer-client 目录中
$ docker cp /var/jenkins_home/workspace/url-rescuer-client/client/dist nginx:/usr/share/nginx/html/url-rescuer-client
# 退出 jenkins 容器，由于 nginx 容器目录 /usr/share/nginx/html 映射到了宿主机的 /data/nginx/www
# 因此进入宿主机 /data/nginx/www 目录看上述拷贝操作是否成功
$ cd /data/nginx/www; ls
```



## 查看 OpenJDK 安装路径

```bash
$ whereis java
java: /usr/bin/java /usr/lib/java /etc/java /usr/share/java /usr/share/man/man1/java.1.gz

$ ll /usr/bin/java
lrwxrwxrwx 1 root root 22 7月   7 21:39 /usr/bin/java -> /etc/alternatives/java

$ ll /etc/alternatives/java
lrwxrwxrwx 1 root root 73 7月   7 21:39 /etc/alternatives/java -> /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64/jre/bin/java
```

从过上面的命令，我们知道 `OpenJDK` 被安装到 `/usr/lib/jvm/` 目录下了。

### 统计数字后再排序（倒序）

```bash
$ netstat -ant|awk '{print $6}'|sort|uniq -c|sort -nr
      9 LISTEN
      8 ESTABLISHED
      1 Foreign
      1 established)
```

### 统计 TCP 状态的个数

```bash
$ netstat -ant|awk '{print $6}'|sort|uniq -c
      1 CLOSE_WAIT
      1 established)
      7 ESTABLISHED
      1 Foreign
      9 LISTEN
```

## 设置时间和时区

```bash
#Control the system time and date
#使用timedatectl命令，控制系统时间和日期
#列出当前时间相关的信息
timedatectl

#列出所有时区
timedatectl list-timezones

#修改时区为上海
timedatectl set-timezone Asia/Shanghai

#校准时间
yum -y install ntp
#通过阿里云时间服务器校准时间
ntpdate ntp1.aliyun.com
```

## 如何重启 Linux系统

```bash
1.reboot 普通重启
2.shutdown -r now 立刻重启(root用户使用)
3.shutdown -r 10 过10分钟自动重启(root用户使用)
4.shutdown -r 20:35 在时间为20:35时候重启(root用户使用)
```

## 添加软连接，指向目录

```bash
#创建/var/test 引向/var/www/test文件夹 
$ ln –s /var/www/test /var/test 

#添加软连接：ln -s 源文件 目标文件 (目标目录下的同名文件夹 -> 源文件)
$ ln -s /usr/local/mycms/upload/ /usr/local/mycms/webapps/mycms/WEB-INF/static/
```

## 查询本机 IP

```bash
$ curl -s <http://myip.ipip.net>
```



## ✔️ 如何刷新/重置mac monsterey 系统的 DNS

```bash
$ sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder
```

参考：[How to Reset and Flush DNS Cache in macOS Monterey 12](https://www.catalinaosx.com/how-to-reset-and-flush-dns-cache-in-macos-monterey-12-fixed/) [Fixed\]

## Debian9 安装 curl

```bash
#首先要更新
$ apt-get update
$ apt-get upgrade

#再安装curl
$ apt-get install curl
```

## CentOS 上安装及使用 besttrace

```bash
wget <https://cdn.ipip.net/17mon/besttrace4linux.zip>
unzip besttrace*
chmod +x besttrace
#登陆ipip.net或ip138.com看本机ip
./besttrace 本机ip
```

## 没有 jps、jmap 命令怎么办？

之前可能安装的是 `java-1.8.0-openjdk.x86_64` (**OpenJDK Runtime Environment 8**)，他是个运行时。

解决方案是：只需要再安装同版本的 `java-1.8.0-openjdk-devel.x86_64` (**OpenJDK 8 Development Environment**) 即可。

```bash
$ yum install -y java-1.8.0-openjdk-devel.x86_64
```



## TODO jcmd 命令

`jcmd` 命令用来向 `JVM` 发送诊断命令请求。这些请求对于控制 Java Flight Recordings、故障排除以及诊断 JVM 和 Java 应用程序非常有用。该命令必须用在和 JVM 同一台机器上，并且具有与启动 JVM 相同的有效用户和组标识符。

> The `jcmd` utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings, troubleshoot, and diagnose JVM and Java Applications. It must be used on the same machine where the JVM is running, and have the same effective user and group identifiers that were used to launch the JVM.

### 命令语法

```
jcmd [-l|-h|-help]
jcmd pid|main-class PerfCounter.print
jcmd pid|main-class -f filename
jcmd pid|main-class command[ arguments]
```

### 查看 jcmd 帮助

```bash
$ jcmd -h
# 或者
$ jcmd -help
```

### 查看进程列表

```bash
# 参数 -l 用于列出当前主机上的所有 JVM 进程列表
$ jcmd -l
6 /usr/share/jenkins/jenkins.war
17694 sun.tools.jcmd.JCmd
```

空格前面是进程的 `pid`，后面跟着进程的 `main class`。

### 查看进程可用的命令

```bash
# 这里是命令后跟 pid，也可以指定 main class，但建议使用 pid，因为更方便
$ jcmd 6 help
# 或者 jcmd /usr/share/jenkins/jenkins.war help
6:
VM.unlock_commercial_features
JFR.configure
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.native_memory
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
VM.classloader_stats
GC.rotate_log
Thread.print
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.finalizer_info
GC.heap_info
GC.run_finalization
GC.run
VM.uptime
VM.dynlibs
VM.flags
VM.system_properties
VM.command_line
VM.version
help

For more information about a specific command use 'help <command>'.
```

命令执行后，会将指定进程所有可用的命令都打印出来，这些命令提供了各种诊断功能。

### 打印所有命令的简单说明

```bash
$ jcmd 6 help -all help
6:
VM.native_memory
	Print native memory usage

ManagementAgent.stop
	Stop remote management agent.

ManagementAgent.start_local
	Start local management agent.

ManagementAgent.start
	Start remote management agent.

VM.classloader_stats
	Print statistics about all ClassLoaders.

GC.rotate_log
	Force the GC log file to be rotated.

Thread.print
	Print all threads with stacktraces.

GC.class_stats
	Provide statistics about Java class meta data. Requires -XX:+UnlockDiagnosticVMOptions.

GC.class_histogram
	Provide statistics about the Java heap usage.

GC.heap_dump
	Generate a HPROF format dump of the Java heap.

GC.finalizer_info
	Provide information about Java finalization queue.

GC.heap_info
	Provide generic Java heap information.

GC.run_finalization
	Call java.lang.System.runFinalization().

GC.run
	Call java.lang.System.gc().

VM.uptime
	Print VM uptime.

VM.dynlibs
	Print loaded dynamic libraries.

VM.flags
	Print VM flag options and their current values.

VM.system_properties
	Print system properties.

VM.command_line
	Print the command line used to start this VM instance.

VM.version
	Print JVM version information.

help
	For more information about a specific command use 'help <command>'. With no argument this will show a list of available commands. 'help all' will show help for all commands.
```

### 查看具体命令的帮助

如果想知道每个命令的功能、权限和使用语法，可以通过以下命令查看命令帮助：

```bash
$ jcmd 6 help Thread.print
6:
Thread.print
Print all threads with stacktraces.

Impact: Medium: Depends on the number of threads.

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : Thread.print [options]

Options: (options must be specified using the <key> or <key>=<value> syntax)
	-l : [optional] print java.util.concurrent locks (BOOLEAN, false)
```

### 打印线程信息

该命令用于输出带堆栈跟踪的线程信息。

```bash
$ jcmd 6 Thread.print
6:
2021-09-04 17:05:21
Full thread dump OpenJDK 64-Bit Server VM (25.212-b04 mixed mode):

"FilePath.localPool [#4390]" #49845 daemon prio=5 os_prio=0 tid=0x000055e896622000 nid=0x4610 waiting on condition [0x00007ff35c38e000]
   java.lang.Thread.State: TIMED_WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x0000000087045e50> (a java.util.concurrent.SynchronousQueue$TransferStack)
	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
	at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:460)
	at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)
	at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:941)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1073)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)

"Attach Listener" #49806 daemon prio=9 os_prio=0 tid=0x000055e895caf000 nid=0x4354 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE
...
```

输出线程结果会比较冗长，建议打印到文件中：

```bash
$ jcmd 6 Thread.print > thread-dump.txt
```

也可以使用 `jstack` 命令输出 `thread` 信息，以下命令和上面等效：

```bash
$ jstack 6 > thread-dump.txt
```

`jstack` 命令还可以用于打印远程主机的 `thread` 信息，更多信息请参考 [jstack 命令帮助文档](https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html)。

### 堆信息转储（heap dump）

堆栈信息对于诊断非常重要。

可以使用如下命令将诊断信息打印到指定的文件中，以备后续使用相关工具（如：`VisualVM`、`HPJmeter`、`IBM Heap Analyzer`、[MAT](https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html)）分析 ` 信息。

```bash
$ jcmd 6 GC.heap_dump xxx.dump
```

以上命令将生成格式为 `hprof` 的 heap dump 信息，并输出到当前目录的指定文件中。

以上命令和 `jmap -dump:file=<file> <pid>` 等效。**建议使用 jcmd** 。

### 打印堆的基本信息

```bash
$ jcmd 6 GC.heap_info
6:
 PSYoungGen      total 28672K, used 14018K [0x00000000d7400000, 0x00000000d9180000, 0x0000000100000000)
  eden space 27136K, 49% used [0x00000000d7400000,0x00000000d8118998,0x00000000d8e80000)
  from space 1536K, 39% used [0x00000000d9000000,0x00000000d9098000,0x00000000d9180000)
  to   space 1536K, 0% used [0x00000000d8e80000,0x00000000d8e80000,0x00000000d9000000)
 ParOldGen       total 139776K, used 72833K [0x0000000085c00000, 0x000000008e480000, 0x00000000d7400000)
  object space 139776K, 52% used [0x0000000085c00000,0x000000008a320418,0x000000008e480000)
 Metaspace       used 104175K, capacity 118500K, committed 120984K, reserved 1155072K
  class space    used 11482K, capacity 14484K, committed 15024K, reserved 1048576K
```

### 打印 Class 直方图

打印出 Class  Histogram：

```bash
$ jcmd 6 GC.class_histogram > xxx.txt
```

打印出的信息可能相当冗长，所以一般将命令的输出信息重定向到文件中。

列表信息中，包括了内部类和特定于应用程序的类。**占用内存最多的类列在顶部，类按降序排列**。

更多命令细节请参考命令帮助：

```bash
$ jcmd 6 help GC.class_histogram
6:
GC.class_histogram
Provide statistics about the Java heap usage.

Impact: High: Depends on Java heap size and content.

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : GC.class_histogram [options]

Options: (options must be specified using the <key> or <key>=<value> syntax)
	-all : [optional] Inspect all objects, including unreachable objects (BOOLEAN, false)
```

### 显示类统计信息

该命令需要 `JVM` 指定了 `-XX:+UnlockDiagnosticVMOptions` flag，否则运行命令会提示：

```bash
$ jcmd 6 GC.class_stats
6:
GC.class_stats command requires -XX:+UnlockDiagnosticVMOptions
```

更多关于命令的使用细节，请参考命令帮助：

```bash
$ jcmd 6 help GC.class_stats
6:
GC.class_stats
Provide statistics about Java class meta data. Requires -XX:+UnlockDiagnosticVMOptions.

Impact: High: Depends on Java heap size and content.

Syntax : GC.class_stats [options] [<columns>]

Arguments:
	columns : [optional] Comma-separated list of all the columns to show. If not specified, the following columns are shown: InstBytes,KlassBytes,CpAll,annotations,MethodCount,Bytecodes,MethodAll,ROAll,RWAll,Total (STRING, no default value)

Options: (options must be specified using the <key> or <key>=<value> syntax)
	-all : [optional] Show all columns (BOOLEAN, false)
	-csv : [optional] Print in CSV (comma-separated values) format for spreadsheets (BOOLEAN, false)
	-help : [optional] Show meaning of all the columns (BOOLEAN, false)
```

### 显示 System Properties

打印出指定 JVM 进程设置的所有 System Properties：

```bash
$ jcmd 6 VM.system_properties
6:
#Sat Sep 04 16:54:55 GMT 2021
jna.platform.library.path=/usr/lib\:/lib
java.runtime.name=OpenJDK Runtime Environment
sun.boot.library.path=/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64
java.vm.version=25.212-b04
mail.smtp.sendpartial=true
java.vm.vendor=IcedTea
java.vendor.url=https\://icedtea.classpath.org
path.separator=\:
java.vm.name=OpenJDK 64-Bit Server VM
...
```

### 显示命令行参数

```bash
$ jcmd 6 VM.command_line
6:
VM Arguments:
jvm_args: -Duser.home=/var/jenkins_home -Djenkins.model.Jenkins.slaveAgentPort=50000
java_command: /usr/share/jenkins/jenkins.war
java_class_path (initial): /usr/share/jenkins/jenkins.war
Launcher Type: SUN_STANDARD
```

这些设定的参数，最终会体现在 JVM 的 System Properties 中。

### 显示 VM flags

```bash
$ jcmd 6 VM.flags
6:
-XX:CICompilerCount=2 -XX:InitialHeapSize=130023424 -XX:MaxHeapSize=2051014656 -XX:MaxNewSize=683671552 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=42991616 -XX:OldSize=87031808 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC
```

### 显示虚拟机版本

```bash
$ jcmd VM.version
6:
OpenJDK 64-Bit Server VM version 25.212-b04
JDK 8.0_212
```

### 显示运行时长

打印出指定 JVM 进程正常运行的时长。单位：秒。

```bash
$ jcmd 6 VM.uptime 
6:
15513470.085 s
```

### 显示 finalization 队列信息

```bash
$ jcmd 6 GC.finalizer_info
6:
No instances waiting for finalization found
```

### 调用 java.lang.System.runFinalization

```bash
$ jcmd 6 GC.run_finalization
6:
Command executed successfully
```

### 调用 java.lang.System.gc()

```bash
$ jcmd 6 GC.run
6:
Command executed successfully
```

### 打印所有的 ClassLoader 统计信息

```bash
$ jcmd 6 VM.classloader_stats
...
0x0000000100282d60  0x0000000100285548  0x000055e891973a40      11    110592     63328  hudson.ClassicPluginStrategy$AntClassLoader2
0x0000000100285548  0x0000000100285230  0x0000000000000000       0         0         0  hudson.ClassicPluginStrategy$DependencyClassLoader
0x00000001001babc0  0x000000010000f298  0x000055e8924852a0       0         0         0  com.thoughtworks.xstream.core.util.CompositeClassLoader
0x000000010000f630  0x0000000000000000  0x000055e8924d3440      91    675840    618848  sun.misc.Launcher$ExtClassLoader
0x000000010000e900  0x000000010000e900  0x000055e891de9e20       0         0         0  java.net.URLClassLoader
0x000000010000f298  0x000000010000f630  0x000055e8918a35a0       4     73728     35464  sun.misc.Launcher$AppClassLoader
Total = 1321                                                 18166  121317376  106377664
ChunkSz: Total size of all allocated metaspace chunks
BlockSz: Total size of all allocated metaspace blocks (each chunk has several blocks)
```

### 强制 GC 日志文件轮转（rotate）

```bash
$ jcmd 6 GC.rotate_log
```

前提：启动 JVM 时需要启用 GC 日志记录，以及设置日志轮转相关 flags：

```
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M
```

否则，会提示错误：

```bash
$ jcmd 6 GC.rotate_log
6:
Target VM does not support GC log file rotation.
```

### 查看原生内存使用情况

在启用了 [-XX:NativeMemoryTracking](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html) 的 JVM 中，查看原生内存使用情况：

```bash
$ jcmd 6 VM.native_memory
```



![image-20210907144702010](https://raw.githubusercontent.com/gukt/images/master/github/images20210907144711.png)





### TODO

ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start

- [x] 写一个 hello.jar，打包一个可执行 jar
- [x] 将 hello.jar 运行在本地
- [x] 使用 jcmd 查看 hello。jar 的相关信息
- [x] 使用 jconsole 连接本地 hello jvm
- [x] 使用 visualvm
- [x] 解决 jmc 在 Mac OS 上打不开的问题
- [x] 使用 JFR
- [x] 使用 jmc 连接
- [ ] 将 hello.jar 拷贝到 codedog996, 查看远程连接 jvm
- [ ] 开启 9999 端口，@biz1 主机
- [ ] 如果 biz1 没有安装 java，安装一下最新的 jdk1.8.0
- [ ] 只开 9999 端口为什么连接不上？
- [ ] 

### 参考

1. https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr006.html
2. [jcmd command man page](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jcmd.html)
3. https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html
4. https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html
5. https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html
6. https://dzone.com/articles/try-to-avoid-xxusegclogfilerotation
7. https://www.cnblogs.com/dengq/p/13687510.html
8. https://medium.com/@chrishantha/basic-concepts-of-java-heap-dump-analysis-with-mat-e3615fd79eb



## TODO jmap 命令

该命令用于打印进程的详细信息。

语法：``jmap` [*options*] *pid*`。



## TODO jstat & jstatd 命令详解

### jstatd 

> The `jstatd` command is an RMI server application that monitors for the creation and termination of instrumented Java HotSpot VMs and provides an interface to enable remote monitoring tools to attach to JVMs that are running on the local host.The `jstatd` server requires an RMI registry on the local host. The `jstatd` server attempts to attach to the RMI registry on the default port, or on the port you specify with the `-p` `port` option. If an RMI registry is not found, then one is created within the `jstatd` application that is bound to the port that is indicated by the `-p` `port` option or to the default RMI registry port when the `-p` `port` option is omitted. You can stop the creation of an internal RMI registry by specifying the `-nr` option.

是一个 JMI 服务器应用。它提供一个接口，以使远程监视工具可以通过连接到本机运行的 JVM。

需要本地主机上的 RMI Registry，

它试图使用默认端口附加到 RMI Registry。可以使用 -p 选型设定 RMI Registry 端口。如果 RMI Registry 没有找到，jstatd 进程内部会自动创建一个 RMI Registry 并被绑定到指定的端口（-p 指定的或默认端口），通过 -nr 选型可以禁止jstatd 在进程内部创建 RMI Registry。

Caused by: java.lang.ClassNotFoundException: sun.jvmstat.monitor.remote.RemoteHost

发生这个异常的原因是：端口被占用了。

检查端口占用情况：

```bash
$ 
```







JVM 统计监视工具。

### 命令帮助

```bash
$ jstat -help
Usage: jstat -help|-options
       jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]

Definitions:
  <option>      An option reported by the -options option
  <vmid>        Virtual Machine Identifier. A vmid takes the following form:
                     <lvmid>[@<hostname>[:<port>]]
                Where <lvmid> is the local vm identifier for the target
                Java virtual machine, typically a process id; <hostname> is
                the name of the host running the target Java virtual machine;
                and <port> is the port number for the rmiregistry on the
                target host. See the jvmstat documentation for a more complete
                description of the Virtual Machine Identifier.
  <lines>       Number of samples between header lines.
  <interval>    Sampling interval. The following forms are allowed:
                    <n>["ms"|"s"]
                Where <n> is an integer and the suffix specifies the units as
                milliseconds("ms") or seconds("s"). The default units are "ms".
  <count>       Number of samples to take before terminating.
  -J<flag>      Pass <flag> directly to the runtime system.
```

参数说明：

* options - 选型，可以使用 `jstat -options` 查看支持的所有选项。
* <vimd>

### 统计选项及字段说明

请见 [官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html)。

https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstatd.html#BABHHDIB

https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html

https://www.cnblogs.com/pyvm/articles/11939854.html

https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/rmiregistry.html

https://www.cnblogs.com/easonjim/p/7483739.html

https://www.onekbit.com/ViewBlog/blog/BID20191226100249

https://www.jianshu.com/p/97f09e1648a6

https://blog.csdn.net/renfufei/article/details/53187123

https://blog.csdn.net/q13554515812/article/details/89712423

https://docs.oracle.com/javase/1.5.0/docs/guide/management/agent.html#properties

### jstatd

该工具用来监视 JVM，并使远程监控工具能够附加到 JVM。

> Monitors Java Virtual Machines (JVMs) and enables remote monitoring tools to attach to JVMs. This command is experimental and unsupported.

参考：

1. https://my.oschina.net/usenrong/blog/197816

TODO

- [ ] 连接远程 JVM
- [ ] 



参考：

1. https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html
2. https://www.jianshu.com/p/845924a1b8f2



## RMI

Java RMI用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；

参考：

1. https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/rmiregistry.html



## TODO 使用 JMX 监控和管理远程 JVM

为了启用 JMX 代理以监控和管理 JVM，我们需要在启动 JVM 时，设定一些系统属性。

早期版本需要指定 `com.sun.management.jmxremote`，不过现在已经不需要了。

如果想要启用监控和管理远程服务器，启动 JVM 时添加如下系统属性（System Property）

```properties
com.sun.management.jmxremote.port=9999
```

默认是启用密码验证的，可以使用以下属性设置以禁用密码验证：

```properties
com.sun.management.jmxremote.authenticate=false
```

当禁用密码时，也可以同时禁用 SSL：

```properties
com.sun.management.jmxremote.ssl=false
```

注意：如果禁用了密码和 SSL 验证，任何人只要知道你的远程主机名和端口号，都可以监控和控制 JVM，所以不建议在生产环境中禁用这些验证。



网上很多文章设置了以下系统属性：

```properties
com.sun.management.jmxremote=true
com.sun.management.jmxremote.local.only=false
java.net.preferIPv4Stack=true
```



```sh
java \
-Djava.rmi.server.hostname=codedog996.com \
-Dcom.sun.management.jmxremote.port=9999 \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.ssl=false \
-jar hello.jar
```

```bash
java \
-Dcom.sun.management.jmxremote.port=9999 \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.ssl=false \
-jar hello.jar
```



错误: 找不到口令文件: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.302.b08-0.el7_9.x86_64/jre/lib/management/jmxremote.password



参考：

1. [Official Documentation：Monitoring and Management Using JMX](https://docs.oracle.com/javase/1.5.0/docs/guide/management/agent.html#sysprops)



# 9、🌈 MISC

## 执行 test 时，调用 getClass().getResource() 时，会在那些路径下查找？

编译的文件一般在 out 目录下，该目录下存在两个文件夹：

test 和 production，其中 resources 目录在 out/production 下，如果你要查找一个文件比如：

getClass().getResource("/config") ，如果项目的 resources/config 目录存在（**注意：且要有文件，不然编译时不会将空目录编译到 out/production/ 下**），则就可以正常返回。



## 为什么Guava 中的很多 API 标有 @Beta 注解 IDEA 会提示警告

Guava 中的很多 API 都标有 @Beta 注解，比如：Hashing, EventBus 等。

IDEA 会给使用了这些 API 的地方提示：

'com.google.common.hash.Hashing' is marked unstable with @Beta 

请看这篇文章的讨论：[Is it safe to use Hashing class from com.google.common.hash?](https://stackoverflow.com/questions/53060907/is-it-safe-to-use-hashing-class-from-com-google-common-hash)

总之，没有什么，Guava 已经用的很广泛了。

在 IDEA 里把这个警告给去掉就好了。

按下 "Command + 1"，在提示的“Inspection on “Unstable API Usage” Options” 上点击，然后选择 “Disable Inspection” 即可。或者选择 "Edit inspection profile setting"，然后在弹出框中会自动定位到相应选型，取消勾选即可。



## 解决 git 无法连接仓库的问题

出现的错误：**无法连接仓库：Command "git ls-remote -h -- http://git.laogu.io:10001/root/url-rescuer.git HEAD" returned status code 128**

这是因为在 jenkins 上没有找到 git 的原因，需要在 “全局工具配置” 里配置一下。

```sh
#进入jenkins容器
docker exec -it jenkins sh

#找到git的版本及路径
type git
git is /usr/bin/git

#打印git版本号
git --version
git version 2.20.2

#进入jenkins的全局工具配置，找到git那个组
在Name中填入：git-2.20.2
在Path to Git executable中填入：/usr/bin/git

#进入job的配置页，检查错误是否消失
#如果发现还是报错，将之前填写的用户名删掉重新设置试试
```



## 如何迁移 Jenkins 的 jobs？

其实很简单，将 jobs 目录保存好，再恢复就好了。



## 加速 Jenkins 插件下载

进入：系统管理 -> 插件管理 -> 高级 -> 升级站点。

在 URL 中填入：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json，并提交。

其实这里填的内容就写在`/data/jenkins/hudson.model.UpdateCenter.xml`文件中。

（完）

## Tomcat 8允许访问软连接目录下的文件

修改 conf/context.xml：

```
<!-- Tomcat 7: --><Context allowLinking="true" /><!-- Tomcat 8: --><Context>  <Resources allowLinking="true" /></Context>
```

修改后重启tomcat!

## Springboot 以 jar 包方式运行时指定参数

```bash
#指定main函数参数
$ java -jar foo.jar p1 p2
#上述参数p1,p2通过main函数获取

#覆盖 application.properties中指定的参数值
$ java -jar foo.jar --p1=v1 --p2=v2

#指定System.properties
$ java -jar foo.jar -Dp1=v1 -Dp2=v2
#上述指定的参数可通过System.getProperty("p1")获取
```

## 替换/还原 brew.git 和 homebrew-core.git 仓库地址

```bash
# 替换成阿里巴巴的 brew.git 仓库地址:
$ cd "$(brew --repo)"
$ git remote set-url origin <https://mirrors.ustc.edu.cn/brew.git>

# 替换成阿里巴巴的 homebrew-core.git 仓库地址:
$ cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"
$ git remote set-url origin <https://mirrors.ustc.edu.cn/homebrew-core.git>

#=======================================================

# 还原为官方提供的 brew.git 仓库地址
$ cd "$(brew --repo)"
$ git remote set-url origin <https://github.com/Homebrew/brew.git>

# 还原为官方提供的 homebrew-core.git 仓库地址
$ cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"
$ git remote set-url origin <https://github.com/Homebrew/homebrew-core.git>
```

## 设置访问静态资源

```
#打开默认配置文件
vim /etc/nginx/conf.d/default.conf

#输入一下内容
server {
    listen 80;
    server_name img.xxx.com;
    root /static/;
}
#输入wq保存退出

#重启nginx
systemctl restart nginx
```

## 设置端口转发及访问白名单

```
#打开/etc/nginx/nginx.conf
vim /etc/nginx/nginx.conf

#在http里添加server{...}段：
http {
	...

    server {
        listen       42100;
        server_name  127.0.0.1:8100;
        location / {
            proxy_pass   <http://127.0.0.1:8100>;
        }
				allow 117.136.117.144;
        deny  all;
    }
}
```

## 一个典型的、简单的 logback.xml 配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration scan="true" scanPeriod="180 seconds">
    <!-- 日志文件名-->
    <property name="LOG_FILE_NAME" value="shuliao"/>
    <!-- 日志文件扩展名-->
    <property name="LOG_FILE_EXT_NAME" value="log"/>
    <!-- 日志存放根目录-->
    <property name="LOG_HOME" value="${app.log-home:-/data/shuliao/log}"/>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %class{0}[%line] - %msg%n</pattern>
        </encoder>
    </appender>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_HOME}/${LOG_FILE_NAME}.${LOG_FILE_EXT_NAME}</file>
        <encoder charset="UTF-8" class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <Pattern>%d [%thread] %-5level %class{0}[%line] - %msg%n</Pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/${LOG_FILE_NAME}.%d{yyyy-MM-dd}.%i.${LOG_FILE_EXT_NAME}.zip</fileNamePattern>
            <!-- 每个文件至少 100MB；最多保存 30；最多 20GB -->
            <maxFileSize>100MB</maxFileSize>
            <maxHistory>60</maxHistory>
            <totalSizeCap>20GB</totalSizeCap>
        </rollingPolicy>
    </appender>

    <root level="DEBUG">
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

## 如何设置日志存放根目录？

在 `logback.xml` 文件中：

```xml
<configuration scan="true" scanPeriod="180 seconds">
  <!-- 定义一个 LOG_HOME 属性，该值从 app.log-home 系统属性中读取，如果没有找到该系统属性，则使用指定的默认值（':-'后面的字符串） -->
	<property name="LOG_HOME" value="${app.log-home:-/data/xxx/log}"/>
 	<appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_HOME}/shuliao.log</file>
    		...
  </appender>
  ...
</configuration>
```

在系统启动时，我们只要在启动命令中设定系统属性 `app.log-home` 即可：

```java
$ java -jar -Dapp.log-home=/data/app-name/log app.jar
```

如果在 IDEA 中调试，请在 `Run/Debug Configurations` 对话框中的 `VM Options` 中指定：

```java
-Dapp.log-home=/data/app-name/log
```

### 问题：SizeAndTimeBasedFNATP is deprecated. Use SizeAndTimeBasedRollingPolicy instead

For more information see http://logback.qos.ch/manual/appenders.html#SizeAndTimeBasedRollingPolicy。

## 启动 Jenkins@mac

```bash
#查看本机安装的jenkins相关信息
brew info jenk
#启动jenkins服务
brew services start jenkins
#启动完成后，查看进程
ps aux|grep jenkins
ktgu             98760  10.5 11.1  8055320 934564   ??  S    12:55上午   0:52.98 /usr/bin/java -Dmail.smtp.starttls.enable=true -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpListenAddress=127.0.0.1 --httpPort=8080
#重启jenkins
brew services restart jenkins
#显示所有服务
brew services list
```

### Postman中 body 数据的 4 种填充方式

body数据有4种填充方式：form-data、x-www-form-urlencoded、raw、binary

1. form-data: 表示http请求中的multipart/form-data

2. x-www-form-urlencoded: 会把表单数据转换为键值对

   form-data与x-www-form-urlencoded的区别

   - multipart/form-data：**可以上传文**件**或者键值对**，最后都会转化为一条消息
   - x-www-form-urlencoded：**只能上传键值对**，而且键值对都是通过&间隔分开的

3. raw: 可以上传任意格式的文本，文本不做任何修饰传到服务端。比如传一些xml，或者json数据，或者text文本数据

4. binary: 相当于Content-Type:application/octet-stream,只可以上传二进制数据，通常用来上传文件，但是一次只能上传一个文件

## 过高并发使用 wrk 而非 ab

注意测试的时候用 wrk 不要用其他的工具，比如 ab，当并发过高的时候 ab 自己就是瓶颈，而 wrk 轻松过十万。





